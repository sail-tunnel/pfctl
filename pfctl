#!/bin/bash
# ============================================
# pfctl - iptables 端口转发工具
# https://github.com/sail-tunnel/pfctl
#
# 用法:
#   pfctl add  -p <port> -d <dest_ip> [-s <source_ip>] [-P <protocol>] [--dport <dest_port>]
#   pfctl del  -p <port> -d <dest_ip> [-s <source_ip>] [-P <protocol>] [--dport <dest_port>]
#   pfctl list
#   pfctl save
#   pfctl update
#   pfctl version
#
# 参数:
#   -p, --port     本地监听端口（支持范围，如 8000-9000）
#   -d, --dest     目标 IP（下一跳）
#   -s, --snat     SNAT 源地址（可选，不指定则使用 MASQUERADE）
#   -P, --proto    协议: tcp / udp / both（默认 both）
#   --dport        目标端口（可选，不指定则与本地端口一致；支持范围）
#
# 示例:
#   # 公网转发（自动 MASQUERADE）
#   pfctl add -p 40972 -d 165.101.144.151
#
#   # 内网转发（指定 SNAT 源 IP）
#   pfctl add -p 40972 -d 192.168.80.35 -s 192.168.80.40
#
#   # 端口映射（本地 8443 → 目标 443）
#   pfctl add -p 8443 -d 10.0.0.5 --dport 443
#
#   # 端口范围转发（本地 8000-9000 → 目标 8000-9000）
#   pfctl add -p 8000-9000 -d 10.0.0.5
#
#   # 仅 TCP
#   pfctl add -p 8443 -d 10.0.0.5 -P tcp
#
#   # 删除规则
#   pfctl del -p 40972 -d 165.101.144.151
#
#   # 查看当前 NAT 规则
#   pfctl list
#
#   # 持久化
#   pfctl save
#
#   # 自更新
#   pfctl update
# ============================================

VERSION="1.0.0"

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

info()  { echo -e "${GREEN}[✓]${NC} $*"; }
warn()  { echo -e "${YELLOW}[!]${NC} $*"; }
error() { echo -e "${RED}[✗]${NC} $*"; exit 1; }

usage() {
    cat <<'EOF'
用法:
  pfctl add  -p <port> -d <dest_ip> [-s <source_ip>] [-P <protocol>] [--dport <dest_port>]
  pfctl del  -p <port> -d <dest_ip> [-s <source_ip>] [-P <protocol>] [--dport <dest_port>]
  pfctl list
  pfctl save
  pfctl update
  pfctl version

参数:
  -p, --port     本地监听端口（支持范围，如 8000-9000）
  -d, --dest     目标 IP（下一跳）
  -s, --snat     SNAT 源地址（可选，不指定则使用 MASQUERADE）
  -P, --proto    协议: tcp / udp / both（默认 both）
  --dport        目标端口（可选，不指定则与本地端口一致；支持范围）

示例:
  pfctl add -p 40972 -d 165.101.144.151
  pfctl add -p 40972 -d 192.168.80.35 -s 192.168.80.40
  pfctl add -p 8443 -d 10.0.0.5 --dport 443
  pfctl add -p 8000-9000 -d 10.0.0.5
  pfctl del -p 40972 -d 165.101.144.151
  pfctl list
  pfctl save
  pfctl update
EOF
    exit 1
}

check_root() {
    [[ $EUID -ne 0 ]] && error "请以 root 权限运行此脚本"
}

# ---- 输入校验 ----

validate_ip() {
    local ip="$1"
    if [[ ! "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        error "无效的 IP 地址: $ip"
    fi
    local IFS='.'
    read -ra octets <<< "$ip"
    for octet in "${octets[@]}"; do
        (( octet > 255 )) && error "无效的 IP 地址: $ip（每段不能超过 255）"
    done
}

validate_port() {
    local port="$1"
    local label="$2"
    # 支持单端口 或 范围 (如 8000-9000)
    if [[ "$port" =~ ^([0-9]+)-([0-9]+)$ ]]; then
        local start="${BASH_REMATCH[1]}" end="${BASH_REMATCH[2]}"
        (( start < 1 || start > 65535 )) && error "${label}范围起始端口无效: $start（应为 1-65535）"
        (( end < 1 || end > 65535 ))     && error "${label}范围结束端口无效: $end（应为 1-65535）"
        (( start >= end ))               && error "${label}范围无效: $start 应小于 $end"
    elif [[ "$port" =~ ^[0-9]+$ ]]; then
        (( port < 1 || port > 65535 )) && error "${label}端口无效: $port（应为 1-65535）"
    else
        error "${label}格式无效: $port（应为单端口或范围如 8000-9000）"
    fi
}

# ---- IP 转发 ----

enable_forwarding() {
    if [[ "$(sysctl -n net.ipv4.ip_forward)" != "1" ]]; then
        sysctl -w net.ipv4.ip_forward=1 >/dev/null
        warn "已启用 net.ipv4.ip_forward"
    fi
    if grep -q '^net.ipv4.ip_forward' /etc/sysctl.conf; then
        sed -i 's/^net.ipv4.ip_forward.*/net.ipv4.ip_forward = 1/' /etc/sysctl.conf
    else
        echo 'net.ipv4.ip_forward = 1' >> /etc/sysctl.conf
    fi
}

# ---- 规则操作 ----

# 将端口参数转为 iptables 格式: 单端口不变, 范围 8000-9000 → 8000:9000
port_to_iptables() {
    echo "${1//-/:}"
}

# 将端口参数转为 DNAT 目标格式: 单端口 → ip:port, 范围 → ip:start-end
dnat_target() {
    local dest="$1" dport="$2"
    if [[ "$dport" =~ - ]]; then
        echo "${dest}:${dport}"
    else
        echo "${dest}:${dport}"
    fi
}

apply_rules() {
    local op="$1" port="$2" dest="$3" dport="$4" snat_ip="$5" proto="$6"

    local ipt_port ipt_dport
    ipt_port="$(port_to_iptables "$port")"
    ipt_dport="$(port_to_iptables "$dport")"

    local protocols=()
    case "$proto" in
        tcp)  protocols=(tcp) ;;
        udp)  protocols=(udp) ;;
        both) protocols=(tcp udp) ;;
    esac

    for p in "${protocols[@]}"; do
        iptables -t nat "$op" PREROUTING -p "$p" --dport "$ipt_port" \
            -j DNAT --to-destination "$(dnat_target "$dest" "$dport")" 2>/dev/null || true

        if [[ -n "$snat_ip" ]]; then
            iptables -t nat "$op" POSTROUTING -d "$dest" -p "$p" --dport "$ipt_dport" \
                -j SNAT --to-source "$snat_ip" 2>/dev/null || true
        else
            iptables -t nat "$op" POSTROUTING -d "$dest" -p "$p" --dport "$ipt_dport" \
                -j MASQUERADE 2>/dev/null || true
        fi
    done
}

# ---- 子命令 ----

do_add() {
    enable_forwarding
    # 幂等: 先删再加
    apply_rules -D "$PORT" "$DEST" "$DPORT" "$SNAT_IP" "$PROTO"
    apply_rules -A "$PORT" "$DEST" "$DPORT" "$SNAT_IP" "$PROTO"

    info "已添加转发规则"
    echo "    监听端口:  $PORT ($PROTO)"
    echo "    转发目标:  $DEST:$DPORT"
    echo "    SNAT:      ${SNAT_IP:-MASQUERADE}"
}

do_del() {
    apply_rules -D "$PORT" "$DEST" "$DPORT" "$SNAT_IP" "$PROTO"
    info "已删除转发规则: $PORT → $DEST:$DPORT ($PROTO)"
}

do_list() {
    echo -e "${YELLOW}=== PREROUTING ===${NC}"
    iptables -t nat -L PREROUTING -n -v --line-numbers 2>/dev/null
    echo
    echo -e "${YELLOW}=== POSTROUTING ===${NC}"
    iptables -t nat -L POSTROUTING -n -v --line-numbers 2>/dev/null
}

do_save() {
    if command -v netfilter-persistent &>/dev/null; then
        netfilter-persistent save
    elif [[ -d /etc/iptables ]]; then
        iptables-save > /etc/iptables/rules.v4
    elif command -v apt &>/dev/null; then
        warn "安装 iptables-persistent ..."
        DEBIAN_FRONTEND=noninteractive apt install -y iptables-persistent
        netfilter-persistent save
    elif command -v yum &>/dev/null; then
        yum install -y iptables-services
        service iptables save
    else
        error "无法自动持久化，请手动执行 iptables-save"
    fi
    info "规则已持久化"
}

do_version() {
    echo -e "pfctl ${CYAN}v${VERSION}${NC}"
    echo "https://github.com/sail-tunnel/pfctl"
}

do_update() {
    check_root
    local url="https://raw.githubusercontent.com/sail-tunnel/pfctl/main/pfctl"
    local tmp_file
    tmp_file="$(mktemp)"

    info "正在检查更新..."
    if curl -fsSL "$url" -o "$tmp_file"; then
        local remote_version
        remote_version="$(grep -m1 '^VERSION=' "$tmp_file" | cut -d'"' -f2)"

        if [[ -z "$remote_version" ]]; then
            rm -f "$tmp_file"
            error "无法获取远程版本号"
        fi

        if [[ "$remote_version" == "$VERSION" ]]; then
            rm -f "$tmp_file"
            info "当前已是最新版本 (v${VERSION})"
            return
        fi

        chmod +x "$tmp_file"
        mv -f "$tmp_file" "/usr/local/bin/pfctl"
        info "更新成功: v${VERSION} → v${remote_version}"
    else
        rm -f "$tmp_file"
        error "下载失败，请检查网络连接"
    fi
}

# ---- 主逻辑 ----

[[ $# -lt 1 ]] && usage

ACTION="$1"; shift

case "$ACTION" in
    list)                check_root; do_list;    exit 0 ;;
    save)                check_root; do_save;    exit 0 ;;
    version|--version|-v|--V) do_version;        exit 0 ;;
    update)              do_update;              exit 0 ;;
    add|del) ;;
    -h|--help|help) usage ;;
    *) usage ;;
esac

# 解析参数
PORT="" DEST="" SNAT_IP="" PROTO="both" DPORT=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -p|--port)
            [[ -z "${2:-}" ]] && error "参数 $1 需要一个值"
            PORT="$2"; shift 2 ;;
        -d|--dest)
            [[ -z "${2:-}" ]] && error "参数 $1 需要一个值"
            DEST="$2"; shift 2 ;;
        -s|--snat)
            [[ -z "${2:-}" ]] && error "参数 $1 需要一个值"
            SNAT_IP="$2"; shift 2 ;;
        -P|--proto)
            [[ -z "${2:-}" ]] && error "参数 $1 需要一个值"
            PROTO="$2"; shift 2 ;;
        --dport)
            [[ -z "${2:-}" ]] && error "参数 $1 需要一个值"
            DPORT="$2"; shift 2 ;;
        *) error "未知参数: $1" ;;
    esac
done

# 校验
[[ -z "$PORT" ]] && error "必须指定端口 (-p)"
[[ -z "$DEST" ]] && error "必须指定目标 IP (-d)"
[[ "$PROTO" != "tcp" && "$PROTO" != "udp" && "$PROTO" != "both" ]] && \
    error "协议必须为 tcp / udp / both"

validate_port "$PORT" "本地"
validate_ip   "$DEST"

# SNAT IP 校验
[[ -n "$SNAT_IP" ]] && validate_ip "$SNAT_IP"

# 目标端口默认与本地端口一致
[[ -z "$DPORT" ]] && DPORT="$PORT"

validate_port "$DPORT" "目标"

check_root

case "$ACTION" in
    add) do_add ;;
    del) do_del ;;
esac